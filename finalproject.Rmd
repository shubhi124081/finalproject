---
title: "PhyloBio Final Project"
author: "Shubhi Sharma"
date: "11/28/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```


#1. Set-up

```{r}

#general libraries needed
library(dplyr)
library(reshape2)

# phylo libraries
library(ape) # dependency of phylobase and phytools, used directly for computing branch lengths
library(phytools) # for visualizing trees
library(tidytree) # for manipulating trees w/ data
library(ggtree) #good vis

# spatial libraries
library(raster)
library(sp)
library(rgeos)
library(rgdal)

# modelling library
library(glmnet)

#misc 
library(knitr)
library(kableExtra)
```



```{r}
#file-paths 

FORCE.REBUILD <- TRUE
DEBUG <- FALSE
LOAD.INV <- TRUE #dont run this as FALSE on local machine - too much mem required

project.directory <- ""
if(Sys.info()['user'] == "shubhi"){
  project.directory <- "~/Documents/Yale/Research/ResearchRotation_Jetz"
}else{ #check if this works on hpc
  project.directory <- "~/research" #filepath on farnam 
}

PROJECT.DIR <- file.path(project.directory)
DATA.DIR    <- file.path(PROJECT.DIR, 'data')
CACHE.DIR   <- file.path(PROJECT.DIR, 'cache')

OCC.PATH        <- file.path(DATA.DIR,  'dataFIA.Rdata')
INV.PATH        <- file.path(CACHE.DIR, 'fiaInventory.csv')
TREE.PATH       <- file.path(DATA.DIR, 'FIAphy.Rdata')
ENV.DIR <- ""
if(Sys.info()['user'] == "shubhi"){
  ENV.DIR         <- "~/Documents/Yale/SDMs/env" #remember to load grace/env to local 
}else{ #check if this works on hpc
  ENV.DIR <- "/gpfs/loomis/pi/jetz/data/SDMs/env" #filepath on farnam 
}

ANNOTATION.PATH <- file.path(CACHE.DIR, 'annotations.csv')
BONUS.DIR <- file.path(project.directory, "euforest_bonuslayers")
#TODO: better name for this
USE.TREE <- TRUE # whether the inventory should be built with a tree 

# CRS of data. the inventory will be reprojected to match the env vars
RAW.CRS <- CRS("+proj=longlat +datum=NAD83 +no_defs") # the CRS of the raw data
ENV.CRS <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0") # the CRS of the env vars

ENV.FILES <- c(
  "CHELSA_bio_1.tif",  # mean annual temp
  "CHELSA_bio_4.tif",  # temp seasonality
  "CHELSA_bio_13.tif", # precip of wettest 1/4
  "CHELSA_bio_15.tif", # precip seasonality
  NULL) # NULL at end just means the last line can have a comma too (makes commenting easier). NULL isn't included

BONUS.FILES <- c(
  "phh2o_v2_strata1to4_mean_1km_epsg4326.tif", # mean soil pH over top 4 strata, compiled by Charlie
  "ai_et0.tif", # aridity index
  "et0_yr.tif"# potential evapotranspiration
)
#genFull for all genera 
STUDY.GENUS <- "Pinus"

```


```{r}
#functions needed 
# function for loading the FIA data (which is organized as a plot-tree-species-year record )
occ <- function(file.path = OCC.PATH, sub = FALSE) {
  
  print("1.1 loading FIA")
  if(sub == TRUE){ #only do this if debugging 
    load(file.path(DATA.DIR, "dataSub.Rdata"))
    return(dataSub)
    
  }else{
    
    load(file.path) #loads as dataFIA object
    print("1.2 loaded FIA")
    return(dataFia)
     
  }
 
}

# convert the occurrence records to an inventory

occ2inventory <- function(dataDF){
  
  pkgs <- installed.packages()
  if("reshape2" %in% pkgs == FALSE){
    install.packages("reshape2", dependencies = T)
  }
  # group all the observations (convert from single records to a presence/absence vector for all species)
  
  print("1.3 Melting...")
  dataDF2 <- reshape2::melt(dataDF, id.vars = c("genusSp", "LAT", "LON"))
  dataDF3 <- reshape2::dcast(dataDF2, formula = LAT + LON ~ genusSp, fun.aggregate = length)
  
  print("1.4 Melted")
  return(dataDF3)  
}


# function for loading an inventory of FIA Forest data
inv.forest <- function(inventory.path  = INV.PATH, # where to load/save the inventory
                         occurrence.path = OCC.PATH, # where to find the occurrence data if we need to rebuild
                         load.inv  = LOAD.INV, # whether to load an inventory
                         use.tree = USE.TREE,
                         tree.path = TREE.PATH
                       ) {
  # first try to load the inventory (if force.rebuild == FALSE)
  if(load.inv && !is.null(inventory.path) && file.exists(inventory.path)) {
    print("1.5 loading inventory ...")
   inventory.df <- read.csv(inventory.path)
   print("1.6 loaded")
  } else {
    print("oops! wrong loop")
    occ.df <- occ(occurrence.path, sub = TRUE) #loads as dataFia/dataSub obj
    inventory.df <- occ2inventory(occ.df)
  }
    
    # if tree is NULL, get one from OTL
    if(use.tree) {
      #all.species <- colnames(inventory.df)[3:ncol(inventory.df)] # first two cols are coordinates
      load(tree.path) #loaded as phy
      #tree <- tree.otl(all.species, tree.path)
    }
    
    # if a tree was found, use it to name the columns of the dataset and prune unmatched species
    #TODO: some species could probably be matched manually
    if(!is.null(phy)) {
      # match the names of the species in the inventory w/ the tip labels
      species.names <- colnames(inventory.df)[-which(colnames(inventory.df) %in% c('LON', 'LAT'))]
      species.matches <- gsub(' ', '_', species.names)
      print(species.matches[1:10])
      species.matches <- sapply(species.matches, 
                                function(species) {
                                  phy$tip.label[which(startsWith(phy$tip.label, species))]
                                })
      
      # for species that failed to match a node in the tree, leave the name in the "natural" format
      #TODO: may be simpler to just delete these species for now, but this ends up being done later anyways
      failed.matches <- which(lapply(species.matches, length) == 0)
      species.matches[failed.matches] <- species.names[failed.matches]
      
      # finally, rename the columns
      colnames(inventory.df)[-which(colnames(inventory.df) %in% c('LON', 'LAT'))] <- species.matches
    }
    
    # finally, write the inventory
    #if(save.if.rebuild && !is.null(inventory.path)) {
    #write.csv(inventory.df,
    #            inventory.path,
    #            quote = FALSE,
    #            row.names = FALSE)
    #}

  
  return(inventory.df)
}


#subset fia to study genus 
subset.inv <- function(dataDF = inv, study = STUDY.GENUS){
  cn <- colnames(dataDF)[-c(1,2)]
  sv <- sapply(cn, function(x){gregexpr("_", x)[[1]][1]})
  genus <- sapply(cn, function(x){substr(x, 1, sv[x]-1)})
  if(study != "genFull"){selected <- as.vector(which(genus == study))
  dataSub <- dataDF[, selected]
  dataSub <- cbind(dataDF[, c(1,2)], dataSub)
  print("1.7 Subsetted")
  return(dataSub)
  }else{
  print("1.7 Subsetting skipped")  
  return(dataDF)
  }
  
}


# convert a data frame of euforest data to a spatial object (occurrence or inventory)
df2sp <- function(df, 
                  input.crs = RAW.CRS,
                  output.crs = ENV.CRS){
  # convert a data frame of euforest data to a spatial object (occurrence or inventory)
  
  pkgs <- installed.packages()
  if("sp" %in% pkgs == FALSE){
    install.packages("sp", dependencies = T)
  }
  
  spdf <- SpatialPointsDataFrame(df[, c('LON', 'LAT')],
                                 df[, -which(colnames(df)%in% c('LAT', 'LON'))],
                                 proj4string = (input.crs))
  
  # reproject the data (presumably to match the env variables)
  if(!is.null(output.crs)) {
    spdf <- sp::spTransform(spdf, output.crs)
  }
  print("1.6 Df -> SP")
  return(spdf)
}



# load environmental layers (cropped to some extent)
env.forest <- function(extent,
                         env.dir   = ENV.DIR,
                         env.files = ENV.FILES, 
                         bonus.dir = BONUS.DIR,
                         bonus.files = BONUS.FILES,
                         force.rebuild = FORCE.REBUILD,
                         annotation.path = ANNOTATION.PATH) {
  
  if(!force.rebuild && !is.null(annotation.path) && file.exists(annotation.path)){
    print("2.0 already annotated")
  }else{
    print("2.1 Annotating... ")
  env.paths <- file.path(env.dir, env.files)
  bonus.paths <- file.path(bonus.dir, bonus.files)
  # have to load the layers one at a time because they may have different extent
  env <- raster::stack()
  for(env.path in env.paths) {
    print(paste0("Loading ", env.path, " ..."))
    env.layer <- raster::raster(env.path)
    
    # if necessary, reproject the env layer, but probably best to avoid this if possible
    if(!raster::compareCRS(crs(env.layer), ENV.CRS)) {
      print(paste0("  Reprojecting..."))
      env.layer <- raster::projectRaster(env.layer, ENV.CRS)
    }
    
    if(!is.null(extent)) {
      env.crop <- raster::crop(env.layer, extent)
    }
    env <- raster::addLayer(env, env.crop)
    }
    
    for(bonus.path in bonus.paths){
      print(paste0("Loading ", bonus.path, "...."))
      bonus.layer <- raster::raster(bonus.path)
      
      if(!raster::compareCRS(crs(bonus.layer), ENV.CRS)) {
        print(paste0("  Reprojecting..."))
        bonus.layer <- raster::projectRaster(bonus.layer, ENV.CRS)
      }
      
      if(!is.null(extent)) {
        bonus.crop <- raster::crop(bonus.layer, extent)
      }
      env <- raster::addLayer(env, bonus.crop)
    }
  return(env)
  }
}

# extract/annotate inventory w/ env variables
annotate.spdf <- function(inventory.spdf, # should be the inventory.spdf, but could be occurrences
                          env,
                          annotation.path = ANNOTATION.PATH, # where to load/save annotations
                          force.rebuild   = FORCE.REBUILD # whether to force the extract (if output exists)
) {
  if(!force.rebuild && !is.null(annotation.path) && file.exists(annotation.path)) {
    
    annotations <- read.csv(annotation.path)
    
    annotations.spdf <- sp::SpatialPointsDataFrame(coords = dplyr::select(annotations, LON, LAT),
                                                   data   = dplyr::select(annotations, -LON, -LAT),
                                                   proj4string = crs(inventory.spdf))
    
    #TODO: check that loaded annotations align with inventory.spdf coords
  } else {
    # now done in a previous step when merging the other layers
    # env.crop <- raster::crop(env, extent(inventory.spdf))
    
    annotations <- raster::extract(env, inventory.spdf, method = 'bilinear')
    
    # add the coordinates to the annotations
    annotations.spdf <- sp::SpatialPointsDataFrame(inventory.spdf@coords,
                                                   as.data.frame(annotations),
                                                   proj4string = crs(inventory.spdf))
    
    if(!is.null(annotation.path)) {
      write.csv(cbind(annotations.spdf@coords, annotations.spdf@data), 
                annotation.path,
                quote = FALSE,
                row.names = FALSE)
    }
  }
  print("2.2 Annotated!")
  return(annotations.spdf)
}

build_pipeline <- function(occ.path = OCC.PATH,
                       debug = DEBUG, 
                       load.inv = LOAD.INV,
                       inventory.path = INV.PATH,
                       use.tree = USE.TREE,
                       tree.path = TREE.PATH,
                       study.genus = STUDY.GENUS, 
                       raw.crs = RAW.CRS,
                       env.crs = ENV.CRS,
                       env.dir   = ENV.DIR,
                       env.files = ENV.FILES, 
                       bonus.dir = BONUS.DIR,
                       bonus.files = BONUS.FILES,
                       force.rebuild = FORCE.REBUILD,
                       annotation.path = ANNOTATION.PATH){
  

  
  if(!load.inv){
    
      dataFia <- occ(file.path = occ.path, 
                 sub = debug)
  
  #subFia <- subsetOcc(dataDF = dataFia, 
  #                    study = study.genus) 
    
      inv <- occ2inventory(subFia)
      }
  
  
  inv <- inv.forest(inventory.path = inventory.path,
                    occurrence.path = occurrence.path,
                    load.inv = load.inv,
                    use.tree = use.tree,
                    tree.path = tree.path)
  
  subsetInv <- subset.inv(dataDF = inv, study = study.genus)
  
  inv.sp <- df2sp(df = subsetInv,
                  input.crs = raw.crs,
                  output.crs = env.crs) 
  
  env <- env.forest(extent = inv.sp, 
                    env.dir = env.dir, 
                    env.files = env.files,
                    bonus.dir = bonus.dir, 
                    bonus.files = bonus.files, 
                    force.rebuild = force.rebuild, 
                    annotation.path = annotation.path)
  
  
  inv.annotated <- annotate.spdf(inventory.spdf = inv.sp,
                                 env = env, 
                                 annotation.path = annotation.path, 
                                 force.rebuild = force.rebuild) 
  
  return(list(inv.annotated, subsetInv))
                       }

```


#1 & 2. Load FIA data & annotate


```{r}
#data.annotated <- build_pipeline(study.genus = 'genFull')
data.annotated <- build_pipeline()
inv <- data.annotated[[2]]

env <- data.annotated[[1]]
env.complete <- cbind(env@coords, env@data)

```


#4. load phylogenetic tree

```{r}
load(TREE.PATH) #loaded as phy
pine.sp <- colnames(inv)[-c(which(colnames(inv) %in% c("LON", "LAT")))]

mrca <- phytools::fastMRCA(phy,'Pinus_nigra', 'Pinus_strobus')
clade <- ape::extract.clade(phy, mrca)
pine.phy <- clade
plot(pine.phy)

foo<-function(tree,...){
  fsize<- 230*par()$pin[2]/par()$pin[1]/Ntip(tree)
  phytools::plotTree(tree,fsize=fsize,lwd=1,..., type = "fan")
}

foo(pine.phy)
```


KDE estimation 
```{r}
library("kdensity")
kde = kdensity(mtcars$mpg, start = "gumbel", kernel = "gaussian")
kp <- env.complete.nona$CHELSA_bio_1
rem <- which(!is.finite(env.complete$CHELSA_bio_1))
env.complete.nona <- env.complete[-rem, ]
#check 
table(is.finite(env.complete.nona$CHELSA_bio_4))

tmp <- MASS::kde2d(x = env.complete.nona$CHELSA_bio_1, y = env.complete.nona$CHELSA_bio_13)

#x.prob <- sum(tmp$x * tmp$z[,])
#return to this later 
#annotate by mean for now

#merge inv and env
inv.env<- merge(inv, env.complete, by = c("LAT", "LON"))
rmcols <- c("LON", "LAT", "CHELSA_bio_4", "CHELSA_bio_15", "phh2o_v2_strata1to4_mean_1km_epsg4326", "ai_et0", "et0_yr")
inv.env <- inv.env[, -which(colnames(inv.env) %in% rmcols)]

annotated <- lapply(inv.env[,1:(ncol(inv.env)-2)],  function(x){
  sv <- which(x > 0)
  temp <- mean(inv.env$CHELSA_bio_1[sv], na.rm = TRUE)
  precip <- mean(inv.env$CHELSA_bio_13[sv], na.rm = TRUE)
  vec <- c(temp, precip)
  names(vec) <- c("temp", "precip")
  return(vec)
})
# temp <- as.vector(rep(0, length(pine.sp)))
# precip <- as.vector(rep(0, length(pine.sp)))
# tmp <- as.list()
# for(i in 1:length(pine.sp)){
#   sv <- which(inv.env[,i] > 0)
#   temp <- mean(inv.env$CHELSA_bio_1[sv], na.rm  = T)
#   precip <- mean(inv.env$CHELSA_bio_13[sv], na.rm = T)
#   tmp[[i]] <- list(temp, precip)
# }
# names(temp) <- pine.sp
# names(precip) <- pine.sp
# 
# annotated <- matrix(cbind(temp, precip), ncol = 2)
# rownames(annotated) <- pine.sp
# colnames(annotated) <- c("temp", "precip")
# annotated <- round(annotated, 3)

write.nexus.data(annotated, file = file.path(getwd(), "annotated.nex"))
writeNexus(pine.phy, file = file.path(getwd(), "pine.nex"))
writeNexus(phy, file = file.path(getwd(), "fiaphy.nex"))
```


Fineggling (skip)

```{r}
tree <- phy

xy.final <- merge(inv, env.complete, by = intersect(colnames(inv), colnames(env.complete)))
#xy.final <-xy.final[complete.cases(xy.final), ]

files <- c(ENV.FILES, BONUS.FILES)
x.varnames <- as.vector(sapply(files, function(x){name <- substr(x, 1, nchar(x)-4); return(name)}))

env.matrix <- xy.final[, which(colnames(xy.final) %in% x.varnames)]

# ML estimation of ancestral states 

#organize data correctly 
y.only <-  xy.final[,-c(which(colnames(xy.final)%in% c(x.varnames, "LAT", "LON")))]

ann.temp <- xy.final[, "CHELSA_bio_1"]

meanStates.final <- apply(y.only ,2,function(x, var = ann.temp){ xx <- cbind(x, var)
cond <- which(xx[,1] == 1)
if(length(cond) > 1){
xx <- xx[which(xx[,1] == 1), ]
mean.state <- mean(xx[, 2], na.rm = TRUE)
}else{
  mean.state <- 0
}
return(mean.state)
})

#make sure tiplabels and species match 

meanStates2.final <-meanStates.final[-c(which((names(meanStates.final) %in% tree$tip.label)== FALSE))]

# tmpValues <- c(65, 65, 65) #change this
# names(tmpValues) <- tree$tip.label[c(18, 25, 37)]

#meanStates2.final <- c(meanStates2.final, tmpValues)
#phy2 <- drop.tip(phy, -c((which((phy$tip.label %in% names(meanStates.final))== FALSE)))) #don't do this

fit.mle.final <- fastAnc(tree, meanStates2.final,vars=TRUE,CI=TRUE, method = "GLS")


## projection of the reconstruction onto the edges of the tree
obj.final <-contMap(tree,meanStates2.final,plot=FALSE)

annotated <- as.data.frame(annotated)
annotated <- as.data.frame(t(annotated))
tree <- phy
#tree <- drop.tip(phy, "Umbellularia_californica")
#tree <- drop.tip(phy, "Vernicia_fordii")
#annotated <- annotated[ match( rownames(annotated), tree$tip.label  ), ]
#annotated <- annotated[complete.cases(annotated),]
 
rmrows <- which(rownames(annotated) %in% tree$tip.label == FALSE)
annotated <- annotated[-rmrows, ] 

addtips <- tree$tip.label[which(tree$tip.label %in%  rownames(annotated) == FALSE)]


tree$tip.label[which(tree$tip.label == "\nPinus_echinata")] <- "Pinus_echinata" 
added <- as.data.frame(cbind(temp = rep(0, length(addtips)), precip = rep(0, length(addtips))))
rownames(added) <- addtips

annotated <- rbind(annotated, added)
#tree <- drop.tip(tree, rmtips)

#sanity check - should be true 
nrow(annotated) == length(tree$tip.label)

# Count the number of tips
n_tips = length(tree$tip.label)

root_node = tree$edge[(!tree$edge[,1] %in% tree$edge[,2]),1] %>% unique()
root_age = max( dist.nodes(tree)[,root_node] ) # in millions of years (Mya)

tree$edge.length = tree$edge.length / root_age
root_age = max( dist.nodes(tree)[,root_node] )

label_offset <- 0.05 * root_age
tree_width <- 1.5 * root_age

basic_ggtree <- ggtree( tree) + 
  geom_tiplab( fontface = "italic", offset=label_offset ) +
  xlim(0, tree_width) +
  geom_text2(aes(label=node), col="red", nudge_x=label_offset/2 )

node_values = c( annotated$temp, rep(NA, n_tips-1) )

#basic_ggtree + 
#   geom_tippoint( aes(color=annotated$temp), size=3, alpha=1 )


temp <-  
  ace( 
    annotated$temp, 
    tree, 
    type="continuous", 
    method="GLS", 
    model="BM"  
  )

```



load phylogenetic tree for pines

```{r}
load(TREE.PATH) #loaded as phy
pine.sp <- colnames(xy)[-c(which(colnames(xy) %in% c(x.varnames, "LON", "LAT")))]

mrca <- phytools::fastMRCA(phy,'Pinus_nigra', 'Pinus_strobus')
clade <- ape::extract.clade(phy, mrca)
pine.phy <- clade
plot(pine.phy)

foo<-function(tree,...){
  fsize<- 230*par()$pin[2]/par()$pin[1]/Ntip(tree)
  phytools::plotTree(tree,fsize=fsize,lwd=1,..., type = "fan")
}

#foo(pine.phy)
```

Reconstruct termperature internal states for pines using REML 

```{r}
# ML estimation of ancestral states 

#organize data correctly 
y.only <-  xy[,-c(which(colnames(xy)%in% c(x.varnames, "LAT", "LON")))]

ann.temp <- xy[, "CHELSA_bio_1"]

meanStates <- apply(y.only ,2,function(x, var = ann.temp){ xy <- cbind(x, var)

xy <- xy[which(xy[,1] == 1) , ]
mean.state <- mean(xy[, 2])

return(mean.state)
})

#make sure tiplabels and species match 

meanStates2 <-meanStates[-c(which((names(meanStates) %in% pine.phy$tip.label)== FALSE))]

tmpValues <- c(65, 65, 65)
names(tmpValues) <- pine.phy$tip.label[c(18, 25, 37)]

meanStates2 <- c(meanStates2, tmpValues)
#pine.phy2 <- drop.tip(pine.phy, -c((which((pine.phy$tip.label %in% names(meanStates))== FALSE)))) #don't do this
meanStates2 <- meanStates2/10
fit.mle <- fastAnc(pine.phy2, meanStates2,vars=TRUE,CI=TRUE)


## projection of the reconstruction onto the edges of the tree
obj<-contMap(pine.phy2,meanStates2,plot=TRUE)
plot(obj,type="fan",legend=0.7*max(nodeHeights(pine.phy)),
    fsize=c(0.7,0.9))
mleDf <- as.data.frame(cbind(Mean = fit.mle$ace, Var = fit.mle$var, CI = fit.mle$CI95))
colnames(mleDf) <- c("Mean", "Var", "Lower CI", "Upper CI")

```

Reconstruct temperature internal states
Comparisons to BM and OU model simulations 

```{r}

#some functions needed 

fastBM<-function(tree,a=0,mu=0,sig2=1,bounds=c(-Inf,Inf),internal=FALSE,nsim=1,...){
	# some minor error checking
	if(!inherits(tree,"phylo")) stop("tree should be object of class \"phylo\".")
	## order
	if(is.null(attr(tree,"order"))||attr(tree,"order")!="cladewise") tree<-reorder(tree)
	## check to see if alpha & theta
	if(hasArg(alpha)) alpha<-list(...)$alpha
	else alpha<-NULL
	if(hasArg(theta)) theta<-list(...)$theta
	else theta<-NULL
	if(!is.null(alpha)&&is.null(theta)){
		cat("Warning: alpha but not theta specified in OU model, setting theta to a.\n")
		theta<-a
	}
	## check for OU w. trend (not permitted)
	if(!is.null(alpha)&&mu!=0)
		cat("Warning: OU with a trend not permitted. Trend parameter will be ignored.\n")
	## check for OU w. bounds (not permitted)
	if(!is.null(alpha)&&(bounds[1]!=-Inf||bounds[2]!=Inf))
		cat("Warning: OU with bounds not permitted. Bounds will be ignored.\n")
	## if BM
	if(is.null(alpha)) {x<-simBM(tree,a,mu,sig2,bounds,internal,nsim)
	}else{
	  x<-if(nsim==1) {simOU(tree,alpha,sig2,theta,a,internal) 
	    }else{
	      replicate(nsim,simOU(tree,alpha,sig2,theta,a,internal))
	    }
	}
	      
	x
}

## internal function does BM simulation
## written by Liam J. Revell 2011, 2013
simBM<-function(tree,a,mu,sig2,bounds,internal,nsim){
	if(bounds[2]<bounds[1]){
		warning("bounds[2] must be > bounds[1]. Simulating without bounds.")
		bounds<-c(-Inf,Inf)
	}
	if(bounds[1]==-Inf&&bounds[2]==Inf) no.bounds=TRUE
	else no.bounds=FALSE
	if(a<bounds[1]||a>bounds[2]){
		warning("a must be bounds[1]<a<bounds[2]. Setting a to midpoint of bounds.")
		a<-bounds[1]+(bounds[2]-bounds[1])/2
	}
	if(sig2<0){
		warning("sig2 must be > 0.  Setting sig2 to 1.0.")
		sig2=1.0
	}
	# function for reflection off bounds
	reflect<-function(yy,bounds){
		while(yy<bounds[1]||yy>bounds[2]){
			if(yy<bounds[1]) yy<-2*bounds[1]-yy
			if(yy>bounds[2]) yy<-2*bounds[2]-yy
		}
		return(yy)
	}
	# how many species?
	n<-length(tree$tip)
	# first simulate changes along each branch
	x<-matrix(data=rnorm(n=length(tree$edge.length)*nsim,mean=rep(mu*tree$edge.length,nsim),sd=rep(sqrt(sig2*tree$edge.length),nsim)),length(tree$edge.length),nsim)
	# now add them up
	y<-array(0,dim=c(nrow(tree$edge),ncol(tree$edge),nsim))
	for(i in 1:nrow(x)){
		if(tree$edge[i,1]==(n+1))
			y[i,1,]<-a
		else
			y[i,1,]<-y[match(tree$edge[i,1],tree$edge[,2]),2,]

		y[i,2,]<-y[i,1,]+x[i,]
		if(!no.bounds) y[i,2,]<-apply(as.matrix(y[i,2,]),1,function(yy) reflect(yy,bounds))
	}
	rm(x); x<-matrix(data=rbind(y[1,1,],as.matrix(y[,2,])),length(tree$edge.length)+1,nsim)
	rownames(x)<-c(n+1,tree$edge[,2])
	x<-as.matrix(x[as.character(1:(n+tree$Nnode)),])
	rownames(x)[1:n]<-tree$tip.label
	# return simulated data
	if(internal==TRUE)
		return(x[1:nrow(x),]) # include internal nodes
	else
		return(x[1:length(tree$tip.label),]) # tip nodes only
}

## internal function does BM simulation
## written by Liam J. Revell 2013
simOU<-function(tree,alpha,sig2,theta,a0,internal){
	tree<-reorder(tree,"cladewise")
	X<-matrix(0,nrow(tree$edge),ncol(tree$edge))
	root<-length(tree$tip.label)+1
	X[which(tree$edge[,1]==root),1]<-a0
	for(i in 1:nrow(X)){
		t<-tree$edge.length[i]
		s2<-sig2*(1-exp(-2*alpha*t))/(2*alpha)
		X[i,2]<-exp(-alpha*t)*X[i,1]+(1-exp(-alpha*t))*theta+rnorm(n=1,sd=sqrt(s2))
		ii<-which(tree$edge[,1]==tree$edge[i,2])
		if(length(ii)>0) X[ii,1]<-X[i,2]
	}
	x<-sapply(1:max(tree$edge),function(x,y,tree) y[which(tree$edge==x)[1]],y=X,tree=tree)
	x<-setNames(x,c(tree$tip.label,1:tree$Nnode+length(tree$tip.label)))
	if(internal==TRUE)
		return(x) # include internal nodes
	else
		return(x[1:length(tree$tip.label)]) # tip nodes only
}
pine.phy2 <- drop.tip(pine.phy, "\nPinus_echinata")
pine.phy2 <- drop.tip(pine.phy2, "Pinus_pungens")

#sanity check - this should be true 
(length(pine.phy2$tip.label) -1) == pine.phy2$Nnode

sv <- which(names(meanStates2) %in% c("\nPinus_echinata", "Pinus_pungens"))
meanStates2 <- meanStates2[-sv]

x <- fastBM(pine.phy2, internal =F)
phenogram(pine.phy2, scale(meanStates2)[,1], spread.labels = TRUE)
phenogram(pine.phy2, scale(x)[,1], spread.labels = TRUE)

reconst.real <- fastAnc(pine.phy2, meanStates2)
reconst.sim.bm <- fastAnc(pine.phy2, x)

plot(scale(reconst.real), scale(reconst.sim.bm))
abline(lm(scale(reconst.real) ~ scale(reconst.sim.bm)), col = "red", lty = 2)
fit.temp.bm <- lm(scale(reconst.real) ~ scale(reconst.sim.bm))

x.ou <- fastBM(pine.phy2, theta = mean(meanStates2), sig2 = sd(meanStates2))
phenogram(pine.phy2, scale(x.ou)[,1], spread.labels = TRUE)

reconst.sim.ou <- fastAnc(pine.phy2, x.ou)
plot(scale(reconst.real), scale(reconst.sim.ou))
abline(lm(scale(reconst.real) ~ scale(reconst.sim.ou)), col = "red", lty = 2)
fit.temp.ou <- lm(scale(reconst.real)~scale(reconst.sim.ou))
```


Reconstruct precipitation states with bm and ou 

```{r}

#organize data correctly 
y.only <-  xy[,-c(which(colnames(xy)%in% c(x.varnames, "LAT", "LON")))]

ann.precip <- xy[, "CHELSA_bio_13"]

meanStates.precip <- apply(y.only ,2,function(x, var = ann.temp){ xy <- cbind(x, var)

xy <- xy[which(xy[,1] == 1) , ]
mean.state <- mean(xy[, 2])

return(mean.state)
})

#make sure tiplabels and species match 

meanStates2.precip <-meanStates.precip[-c(which((names(meanStates.precip) %in% pine.phy2$tip.label)== FALSE))]

tmpValues <- c(105, 105)
names(tmpValues) <- pine.phy2$tip.label[c(18, 25)]

meanStates2.precip <- c(meanStates2.precip, tmpValues)
#pine.phy2 <- drop.tip(pine.phy, -c((which((pine.phy$tip.label %in% names(meanStates))== FALSE)))) #don't do this

fit.mle.precip <- fastAnc(pine.phy2, meanStates2.precip,vars=TRUE,CI=TRUE)

fit.precip.ou <- anc.ML(pine.phy2, meanStates2.precip, model = "OU", theta = mean(meanStates2.precip), sig2 = sd(meanStates2.precip), alpha = 1)
fit.precip.bm <- anc.ML(pine.phy2, meanStates2.precip, model = "BM", theta = 0, alpha = 0) #this isn't right

## projection of the reconstruction onto the edges of the tree
obj.precip<-contMap(pine.phy2,meanStates2.precip,plot=TRUE)

plot(obj,type="fan",legend=0.7*max(nodeHeights(pine.phy2)),
    fsize=c(0.7,0.9))
mleDf <- as.data.frame(cbind(Mean = fit.mle$ace, Var = fit.mle$var, CI = fit.mle$CI95))
colnames(mleDf) <- c("Mean", "Var", "Lower CI", "Upper CI")


reconst.real.precip <- fastAnc(pine.phy2, meanStates2.precip)
plot(scale(reconst.real.precip), scale(reconst.sim.bm))
abline(lm(scale(reconst.real.precip) ~ scale(reconst.sim.bm)), col = "red", lty = 2)
precip.fit.bm <- lm(scale(reconst.real.precip) ~ scale(reconst.sim.bm))

x.ou.precip <- fastBM(pine.phy2, theta = mean(meanStates2.precip), sig2 = sd(meanStates2.precip))
reconst.sim.ou.precip <- fastAnc(pine.phy2, x.ou.precip)
plot(scale(reconst.real.precip), scale(reconst.sim.ou.precip))
abline(lm(scale(reconst.real.precip) ~ scale(reconst.sim.ou.precip)), col = "red", lty = 2)
precip.fit.ou <- lm(scale(reconst.sim.ou.precip) ~ scale(reconst.real.precip))



```

Estimate correlations 

```{r}
temp_c <- pic(meanStates2, pine.phy2)
precip_c <- pic(meanStates2.precip, pine.phy2)
cor.test(temp_c, precip_c)
#Correlation of 0.97 hello! pave the way for mvn bm 

```


Some tests for phylogenetic signal 
```{r}
K.precip <- phylosig(pine.phy2, meanStates2.precip, test = T)
lambda.precip <- phylosig(pine.phy2, meanStates2.precip, method = "lambda", test = T)

K.temp <- phylosig(pine.phy2, meanStates2, test = T)
lambda.temp <- phylosig(pine.phy2, meanStates2, method = "lambda", test = T)
```


Archived sections 


```{r}

#debugging w functions from ape - remove from environment after 
.getSEs <- function(out)
{
    h <- out$hessian
    if (any(diag(h) == 0)) {
        warning("The likelihood gradient seems flat in at least one dimension (gradient null):\ncannot compute the standard-errors of the transition rates.\n")
        se <- rep(NaN, nrow(h))
    } else {
        se <- sqrt(diag(solve(h)))
    }
    se
}

ace <- function(x, phy, type = "continuous",
           method = if (type == "continuous") "REML" else "ML",
           CI = TRUE, model = if (type == "continuous") "BM" else "ER",
           scaled = TRUE, kappa = 1, corStruct = NULL, ip = 0.1,
           use.expm = FALSE, use.eigen = TRUE, marginal = FALSE){
    if (!inherits(phy, "phylo"))
        stop('object "phy" is not of class "phylo"')
    if (is.null(phy$edge.length))
        stop("tree has no branch lengths")
    type <- match.arg(type, c("continuous", "discrete"))
    nb.tip <- length(phy$tip.label)
    nb.node <- phy$Nnode
    if (nb.node != nb.tip - 1)
        stop('"phy" is not rooted AND fully dichotomous.')
    if (length(x) != nb.tip)
        stop("length of phenotypic and of phylogenetic data do not match.")
    if (!is.null(names(x))) {
        if(all(names(x) %in% phy$tip.label))
          x <- x[phy$tip.label]
        else warning("the names of 'x' and the tip labels of the tree do not match: the former were ignored in the analysis.")
    }
    obj <- list()
    if (kappa != 1) phy$edge.length <- phy$edge.length^kappa
    if (type == "continuous") {
        switch(method, "REML" = {
            minusLogLik <- function(sig2) {
                if (sig2 < 0) return(1e100)
                V <- sig2 * vcv(phy)
                ## next three lines borrowed from dmvnorm() in 'mvtnorm'
                distval <- mahalanobis(x, center = mu, cov = V)
                logdet <- sum(log(eigen(V, symmetric = TRUE, only.values = TRUE)$values))
                (nb.tip * log(2 * pi) + logdet + distval)/2
            }
            mu <- rep(ace(x, phy, method="pic")$ace[1], nb.tip)
            out <- nlm(minusLogLik, 1, hessian = TRUE)
            sigma2 <- out$estimate
            se_sgi2 <- sqrt(1/out$hessian)
            tip <- phy$edge[, 2] <= nb.tip
            minus.REML.BM <- function(p) {
                x1 <- p[phy$edge[, 1] - nb.tip]
                x2 <- numeric(length(x1))
                x2[tip] <- x[phy$edge[tip, 2]]
                x2[!tip] <- p[phy$edge[!tip, 2] - nb.tip]
                -(-sum((x1 - x2)^2/phy$edge.length)/(2 * sigma2) -
                  nb.node * log(sigma2))
            }
            out <- nlm(function(p) minus.REML.BM(p),
                       p = rep(mu[1], nb.node), hessian = TRUE)
            obj$resloglik <- -out$minimum
            obj$ace <- out$estimate
            names(obj$ace) <- nb.tip + 1:nb.node
            obj$sigma2 <- c(sigma2, se_sgi2)
            if (CI) {
                se <- .getSEs(out)
                tmp <- se * qt(0.025, nb.node)
                obj$CI95 <- cbind(obj$ace + tmp, obj$ace - tmp)
            }
        }, "pic" = {
            if (model != "BM")
                stop('the "pic" method can be used only with model = "BM".')
            ## See pic.R for some annotations.
            phy <- reorder(phy, "postorder")
            phenotype <- numeric(nb.tip + nb.node)
            phenotype[1:nb.tip] <- if (is.null(names(x))) x else x[phy$tip.label]
            contr <- var.con <- numeric(nb.node)
            ans <- .C(C_pic, as.integer(nb.tip),
                      as.integer(phy$edge[, 1]), as.integer(phy$edge[, 2]),
                      as.double(phy$edge.length), as.double(phenotype),
                      as.double(contr), as.double(var.con),
                      as.integer(CI), as.integer(scaled))
            obj$ace <- ans[[5]][-(1:nb.tip)]
            names(obj$ace) <- nb.tip + 1:nb.node
            if (CI) {
                se <- sqrt(ans[[7]])
                tmp <- se * qnorm(0.025)
                obj$CI95 <- cbind(obj$ace + tmp, obj$ace - tmp)
            }
        }, "ML" = {
            if (model == "BM") {
                tip <- phy$edge[, 2] <= nb.tip
                dev.BM <- function(p) {
                    if (p[1] < 0) return(1e100) # in case sigma^2 is negative
                    x1 <- p[-1][phy$edge[, 1] - nb.tip]
                    x2 <- numeric(length(x1))
                    x2[tip] <- x[phy$edge[tip, 2]]
                    x2[!tip] <- p[-1][phy$edge[!tip, 2] - nb.tip]
                    -2 * (-sum((x1 - x2)^2/phy$edge.length)/(2*p[1]) -
                          nb.node * log(p[1]))
                }
                out <- nlm(function(p) dev.BM(p),
                           p = c(1, rep(mean(x), nb.node)), hessian = TRUE)
                obj$loglik <- -out$minimum / 2
                obj$ace <- out$estimate[-1]
                names(obj$ace) <- (nb.tip + 1):(nb.tip + nb.node)
                se <- .getSEs(out)
                obj$sigma2 <- c(out$estimate[1], se[1])
                if (CI) {
                    tmp <- se[-1] * qt(0.025, nb.node)
                    obj$CI95 <- cbind(obj$ace + tmp, obj$ace - tmp)
                }
            }
        }, "GLS" = {
            if (is.null(corStruct))
                stop('you must give a correlation structure if method = "GLS".')
            if (class(corStruct)[1] == "corMartins")
                M <- corStruct[1] * dist.nodes(phy)
            if (class(corStruct)[1] == "corGrafen")
                phy <- compute.brlen(attr(corStruct, "tree"),
                                     method = "Grafen",
                                     power = exp(corStruct[1]))
            if (class(corStruct)[1] %in% c("corBrownian", "corGrafen")) {
                dis <- dist.nodes(attr(corStruct, "tree"))
                MRCA <- mrca(attr(corStruct, "tree"), full = TRUE)
                M <- dis[as.character(nb.tip + 1), MRCA]
                dim(M) <- rep(sqrt(length(M)), 2)
            }
            varAY <- M[-(1:nb.tip), 1:nb.tip]
            varA <- M[-(1:nb.tip), -(1:nb.tip)]
            V <- corMatrix(Initialize(corStruct, data.frame(x)),
                           corr = FALSE)
            invV <- solve(V)
            o <- gls(x ~ 1, data.frame(x), correlation = corStruct)
            GM <- o$coefficients
            obj$ace <- drop(varAY %*% invV %*% (x - GM) + GM)
            names(obj$ace) <- (nb.tip + 1):(nb.tip + nb.node)
            if (CI) {
                se <- sqrt((varA - varAY %*% invV %*% t(varAY))[cbind(1:nb.node, 1:nb.node)])
                tmp <- se * qnorm(0.025)
                obj$CI95 <- cbind(obj$ace + tmp, obj$ace - tmp)
            }
        })
    } else { # type == "discrete"
        if (method != "ML")
            stop("only ML estimation is possible for discrete characters.")
        if (any(phy$edge.length <= 0))
            stop("some branches have length zero or negative")
        if (!is.factor(x)) x <- factor(x)
        nl <- nlevels(x)
        lvls <- levels(x)
        x <- as.integer(x)
        if (is.character(model)) {
            rate <- matrix(NA, nl, nl)
            switch(model,
                   "ER" = np <- rate[] <- 1,
                   "ARD" = {
                       np <- nl*(nl - 1)
                       rate[col(rate) != row(rate)] <- 1:np
                   },
                   "SYM" = {
                       np <- nl * (nl - 1)/2
                       sel <- col(rate) < row(rate)
                       rate[sel] <- 1:np
                       rate <- t(rate)
                       rate[sel] <- 1:np
                   })
        } else {
            if (ncol(model) != nrow(model))
                stop("the matrix given as 'model' is not square")
            if (ncol(model) != nl)
                stop("the matrix 'model' must have as many rows as the number of categories in 'x'")
            rate <- model
            np <- max(rate)
        }
        index.matrix <- rate
        tmp <- cbind(1:nl, 1:nl)
        index.matrix[tmp] <- NA
        rate[tmp] <- 0
        rate[rate == 0] <- np + 1 # to avoid 0's since we will use this as numeric indexing

        liks <- matrix(0, nb.tip + nb.node, nl)
        TIPS <- 1:nb.tip
        liks[cbind(TIPS, x)] <- 1
        if (anyNA(x)) liks[which(is.na(x)), ] <- 1
        phy <- reorder(phy, "postorder")

        Q <- matrix(0, nl, nl)

        e1 <- phy$edge[, 1]
        e2 <- phy$edge[, 2]
        EL <- phy$edge.length

        if (use.eigen) {
            dev <- function(p, output.liks = FALSE) {
                if (any(is.nan(p)) || any(is.infinite(p))) return(1e+50)
                comp <- numeric(nb.tip + nb.node)
                Q[] <- c(p, 0)[rate]
                diag(Q) <- -rowSums(Q)
                decompo <- eigen(Q)
                lambda <- decompo$values
                GAMMA <- decompo$vectors
                invGAMMA <- solve(GAMMA)
                for (i in seq(from = 1, by = 2, length.out = nb.node)) {
                    j <- i + 1L
                    anc <- e1[i]
                    des1 <- e2[i]
                    des2 <- e2[j]
                    v.l <- GAMMA %*% diag(exp(lambda * EL[i])) %*% invGAMMA %*% liks[des1, ]
                    v.r <- GAMMA %*% diag(exp(lambda * EL[j])) %*% invGAMMA %*% liks[des2, ]
                    v <- v.l * v.r
                    comp[anc] <- sum(v)
                    liks[anc, ] <- v/comp[anc]
                }
                if (output.liks) return(liks[-TIPS, ])
                dev <- -2 * sum(log(comp[-TIPS]))
                if (is.na(dev)) Inf else dev
            }
        } else {
            if (!requireNamespace("expm", quietly = TRUE) && use.expm) {
                warning("package 'expm' not available; using function 'matexpo' from 'ape'")
                use.expm <- FALSE
            }
            E <- if (use.expm) expm::expm # to avoid Matrix::expm
                 else matexpo
            dev <- function(p, output.liks = FALSE) {
                if (any(is.nan(p)) || any(is.infinite(p))) return(1e50)
                comp <- numeric(nb.tip + nb.node) # from Rich FitzJohn
                Q[] <- c(p, 0)[rate]
                diag(Q) <- -rowSums(Q)
                for (i in seq(from = 1, by = 2, length.out = nb.node)) {
                    j <- i + 1L
                    anc <- e1[i]
                    des1 <- e2[i]
                    des2 <- e2[j]
                    v.l <- E(Q * EL[i]) %*% liks[des1, ]
                    v.r <- E(Q * EL[j]) %*% liks[des2, ]
                    v <- v.l * v.r
                    comp[anc] <- sum(v)
                    liks[anc, ] <- v/comp[anc]
                }
                if (output.liks) return(liks[-TIPS, ])
                dev <- -2 * sum(log(comp[-TIPS]))
                if (is.na(dev)) Inf else dev
            }
        }

        out <- nlminb(rep(ip, length.out = np), function(p) dev(p),
                      lower = rep(0, np), upper = rep(1e50, np))
        obj$loglik <- -out$objective/2
        obj$rates <- out$par
        oldwarn <- options("warn")
        options(warn = -1)
        out.nlm <- try(nlm(function(p) dev(p), p = obj$rates, iterlim = 1,
                           stepmax = 0, hessian = TRUE), silent = TRUE)
        options(oldwarn)
        obj$se <- if (class(out.nlm) == "try-error") {
            warning("model fit suspicious: gradients apparently non-finite")
            rep(NaN, np)
        } else .getSEs(out.nlm)
        obj$index.matrix <- index.matrix
        if (CI) {
            lik.anc <- dev(obj$rates, TRUE)
            if (!marginal) {
                Q[] <- c(obj$rates, 0)[rate]
                diag(Q) <- -rowSums(Q)
                for (i in seq(to = 1, by = -2, length.out = nb.node)) {
                    anc <- e1[i] - nb.tip
                    des1 <- e2[i] - nb.tip
                    if (des1 > 0) {
                        P <- matexpo(Q * EL[i])
                        tmp <- lik.anc[anc, ] / (lik.anc[des1, ] %*% P)
                        lik.anc[des1, ] <- (tmp %*% P) * lik.anc[des1, ]
                    }
                    j <- i + 1L
                    des2 <- e2[j] - nb.tip
                    if (des2 > 0) {
                        P <- matexpo(Q * EL[j])
                        tmp <- lik.anc[anc, ] / (lik.anc[des2, ] %*% P)
                        lik.anc[des2, ] <- (tmp %*% P) * lik.anc[des2, ]
                    }
                    lik.anc <- lik.anc / rowSums(lik.anc)
                }
            }
            colnames(lik.anc) <- lvls
            obj$lik.anc <- lik.anc
        }
    }
    obj$call <- match.call()
    class(obj) <- "ace"
    obj
}


logLik.ace <- function(object, ...) object$loglik

deviance.ace <- function(object, ...) -2*object$loglik

AIC.ace <- function(object, ..., k = 2)
{
    if (is.null(object$loglik)) return(NULL)
    ## Trivial test of "type"; may need to be improved
    ## if other models are included in ace(type = "c")
    np <- if (!is.null(object$sigma2)) 1 else length(object$rates)
    -2*object$loglik + np*k
}

### by BB:
anova.ace <- function(object, ...)
{
    X <- c(list(object), list(...))
    df <- lengths(lapply(X, "[[", "rates"))
    ll <- sapply(X, "[[", "loglik")
    ## check if models are in correct order
    dev <- c(NA, 2*diff(ll))
    ddf <- c(NA, diff(df))
    table <- data.frame(ll, df, ddf, dev,
                        pchisq(dev, ddf, lower.tail = FALSE))
    dimnames(table) <- list(1:length(X), c("Log lik.", "Df",
                                           "Df change", "Resid. Dev",
                                           "Pr(>|Chi|)"))
    structure(table, heading = "Likelihood Ratio Test Table",
              class = c("anova", "data.frame"))
}

print.ace <- function(x, digits = 4, ...)
{
    cat("\n    Ancestral Character Estimation\n\n")
    cat("Call: ")
    print(x$call)
    cat("\n")
    if (!is.null(x$loglik))
        cat("    Log-likelihood:", x$loglik, "\n\n")
    if (!is.null(x$resloglik))
        cat("    Residual log-likelihood:", x$resloglik, "\n\n")
    ratemat <- x$index.matrix
    if (is.null(ratemat)) { # to be improved
        class(x) <- NULL
        x$resloglik <- x$loglik <- x$call <- NULL
        print(x)
    } else {
        dimnames(ratemat)[1:2] <- dimnames(x$lik.anc)[2]
        cat("Rate index matrix:\n")
        print(ratemat, na.print = ".")
        cat("\n")
        npar <- length(x$rates)
        estim <- data.frame(1:npar, round(x$rates, digits), round(x$se, digits))
        cat("Parameter estimates:\n")
        names(estim) <- c("rate index", "estimate", "std-err")
        print(estim, row.names = FALSE)
        if (!is.null(x$lik.anc)) {
            cat("\nScaled likelihoods at the root (type '...$lik.anc' to get them for all nodes):\n")
            print(x$lik.anc[1, ])
        }
    }
}
```






